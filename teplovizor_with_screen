#include <Wire.h>
#include <pin_magic.h>
#include <registers.h>
#include <SPFD5408_Adafruit_GFX.h>
#include <SPFD5408_Adafruit_TFTLCD.h>
#include <SPFD5408_TouchScreen.h>
#include <SPFD5408_Util.h>

#include "Platform.h"
#include "MeasureConfigurator.h"
#include "Interpolation.h"


Platform platform;
MeasureConfigurator configurator;
// Calibrates value
#define SENSIBILITY 300
#define MINPRESSURE 10
#define MAXPRESSURE 1000

//These are the pins for the shield!
#define YP A1
#define XM A2
#define YM 7
#define XP 6
// Init TouchScreen:
short TS_MINX = 150;
short TS_MINY = 120;
short TS_MAXX = 920;
short TS_MAXY = 940;
TouchScreen ts = TouchScreen(XP, YP, XM, YM, SENSIBILITY);

// LCD Pin

#define LCD_CS A3
#define LCD_CD A2
#define LCD_WR A1
#define LCD_RD A0
#define LCD_RESET A4 // Optional : otherwise connect to Arduino's reset pin

// Assign human-readable names to some common 16-bit color values:
#define BLACK   0x0000
#define BLUE    0x001F
#define RED     0xF800
#define GREEN   0x07E0
#define CYAN    0x07FF
#define MAGENTA 0xF81F
#define YELLOW  0xFFE0
#define WHITE   0xFFFF
#define COLORS_COUNT 0x0008
uint16_t colors[COLORS_COUNT] = {RED, BLUE, BLACK, GREEN, CYAN, MAGENTA, YELLOW, WHITE};
// Init LCD

Adafruit_TFTLCD tft(LCD_CS, LCD_CD, LCD_WR, LCD_RD, LCD_RESET);

// Dimensions

uint16_t width = 0;
uint16_t height = 0;
uint16_t idx = 1;
// Buttons

#define BUTTONS 2
#define BUTTON_START 0
#define BUTTON_MENU 1

#define MENU_OPTIONS 5
#define MENU_GRID 0
#define MENU_COLOR 1
#define MENU_TIME 2
#define MENU_ANGLE 3
#define MENU_BACK 4

#define GRID_OPTIONS 3
#define GRID_MINUS 0
#define GRID_PLUS 1
#define GRID_BACK 2

#define COLOR_OPTIONS 3
#define COLOR_LEFT 0
#define COLOR_RIGHT 1
#define COLOR_BACK 2

#define TIME_OPTIONS 3
#define TIME_LEFT 0
#define TIME_RIGHT 1
#define TIME_BACK 2

#define ANGLE_OPTIONS 3
#define ANGLE_LEFT 0
#define ANGLE_RIGHT 1
#define ANGLE_BACK 2

#define START_OPTIONS 2
#define BUTTON_BACK 0
#define BUTTON_REFRESH 1


Adafruit_GFX_Button buttons[BUTTONS];
Adafruit_GFX_Button menu_buttons[MENU_OPTIONS];
Adafruit_GFX_Button grid_buttons[GRID_OPTIONS];
Adafruit_GFX_Button color_buttons[COLOR_OPTIONS];
Adafruit_GFX_Button time_buttons[TIME_OPTIONS];
Adafruit_GFX_Button angle_buttons[ANGLE_OPTIONS];
Adafruit_GFX_Button start_buttons[START_OPTIONS];

uint16_t buttons_y = 0;
float temp = 0;
Adafruit_MLX90614 modIrTemp = Adafruit_MLX90614();
double** source_arr;
double** new_arr;
uint16_t pixel_color;
uint16_t min_color = 16;
uint16_t max_color = 24;
int grid_width;
int grid_height;
int color_choice;
int time_choice;
int angle_left;
int angle_right;
// функция вывода массива в консоль Arduino
void printArray(double** arr, int rows, int columns) {
  for (int r = 0; r < rows; ++r) {
    for (int c = 0; c < columns; ++c) {
      Serial.print(arr[r][c]); Serial.print(' ');
    }
    Serial.println();
  }
}
uint16_t gray_colors[32];
uint16_t rol_colors[32];
void setup() {
  int red = 0;
  int blue = 0;
  int green = 0;
  for (int i = 0; i < 32; ++i) {
    gray_colors[i] = (red << 11) + (green << 5) + blue;
    red++;
    blue++;
    green += 2;
  }
  red = 31;
  blue = 31;
  green = 0;
  
  for (int i = 0; i < 32;++i){
    if (blue > 0){
    rol_colors[i] = (red << 11) + (green << 5) + blue;
    }else{
      rol_colors[i] = (red << 11) + (green << 5);
    }
    green += 2;
    blue -= 8;
  }
  

  int horPort = 24;
  int verPort = 22;

  platform = Platform(horPort, verPort);
  platform.setVerAngle(90);
  platform.setHorAngle(90);
  tft.reset();
  tft.begin(0x9341);
  width = tft.width() - 1;
  height = tft.height() - 1;
  initializeButtons();
  drawBorder();

  // Initial screen


  tft.setCursor (30, 50);
  tft.setTextSize (3);
  tft.setTextColor(BLACK);
  tft.println("Welcome To");
  tft.setCursor (40, 85);
  tft.println("Main Menu");
  tft.setCursor (55, 150);
  tft.setTextSize (2);
  tft.setTextColor(BLACK);
  tft.println("Teplovizor");

  tft.setCursor (70, 250);
  tft.setTextSize (1);
  tft.setTextColor(BLACK);
  tft.println("Touch to proceed");
  modIrTemp.begin();
  // Wait touch

  waitOneTouch();
  main_menu();
  int singleTime = 500;
  int horMin = 60;
  int horMax = 120;
  int verMin = 60;
  int verMax = 120;
  int horSection = 5;
  int verSection = 5;

  // инициализация конфигуратора
  configurator = MeasureConfigurator(horMin, horMax, horSection,
                                     verMin, verMax, verSection,
                                     singleTime, platform);

  Serial.begin(9600);
}
int flag = 0;
void loop() {

  delay(1000); // can adjust this for faster/slower updates
  TSPoint p;

  //Serial.println("Source array: ");
  //printArray(source_arr, configurator.getVerSection(), configurator.getHorSection());
  // интерполяция тепловой карты

  //Serial.println("Interpolated array: ");
  //printArray(new_arr, 215, 240);

  // Wait a touch
  temp = modIrTemp.readAmbientTempC();
  digitalWrite(13, HIGH);

  p = waitOneTouch();

  digitalWrite(13, LOW);

  // Map of values

  p.x = mapXValue(p);
  p.y = mapYValue(p);
  if (idx == 1) {
    for (uint8_t b = 0; b < BUTTONS; b++) {

      if (buttons[b].contains(p.x, p.y)) {
        // Action
        switch (b) {
          case BUTTON_START:
            flag = start(flag, temp, new_arr);
            idx += 2;
            break;
          case BUTTON_MENU:
            menu();
            idx++;
            break;
        }
      }
    }
  }
  digitalWrite(13, HIGH);

  p = waitOneTouch();

  digitalWrite(13, LOW);

  // Map of values

  p.x = mapXValue(p);
  p.y = mapYValue(p);
  if (idx == 2) {
    for (uint8_t b = 0; b < MENU_OPTIONS; b++) {

      if (menu_buttons[b].contains(p.x, p.y)) {
        // Action
        switch (b) {
          case MENU_GRID:
            grid_menu();
            idx += 2;
            break;
          case MENU_COLOR:
            color_menu();
            idx += 3;
            break;
          case MENU_TIME:
            time_menu();
            idx += 4;
            break;
          case MENU_ANGLE:
            angle_menu();
            idx += 5;
            break;
          case MENU_BACK:
            main_menu();
            idx--;
            break;
        }
      }
    }
  }
  digitalWrite(13, HIGH);

  p = waitOneTouch();

  digitalWrite(13, LOW);

  // Map of values

  p.x = mapXValue(p);
  p.y = mapYValue(p);
  if (idx == 3) {
    for (uint8_t b = 0; b < START_OPTIONS; b++) {
      if (start_buttons[b].contains(p.x, p.y)) {
        switch (b) {
          case BUTTON_BACK:
            main_menu();
            idx -= 2;
            break;
          case BUTTON_REFRESH:
            flag = start(flag, temp, new_arr);
            break;
        }
      }
    }
  }
  if (idx == 4) {
    for (uint8_t b = 0; b < GRID_OPTIONS; b++) {
      if (grid_buttons[b].contains(p.x, p.y)) {
        switch (b) {
          case GRID_MINUS:
            grid_menu();
            break;
          case GRID_PLUS:
            grid_menu();
            break;
          case GRID_BACK:
            menu();
            idx -= 2;
            break;
        }
      }
    }
  }
  if (idx == 5) {
    for (uint8_t b = 0; b < COLOR_OPTIONS; b++) {
      if (color_buttons[b].contains(p.x, p.y)) {
        switch (b) {
          case COLOR_LEFT:
            color_menu();
            break;
          case COLOR_RIGHT:
            color_menu();
            break;
          case COLOR_BACK:
            menu();
            idx -= 3;
            break;
        }
      }
    }
  }
  if (idx == 6) {
    for (uint8_t b = 0; b < TIME_OPTIONS; b++) {
      if (time_buttons[b].contains(p.x, p.y)) {
        switch (b) {
          case TIME_LEFT:
            time_menu();
            break;
          case TIME_RIGHT:
            time_menu();
            break;
          case TIME_BACK:
            menu();
            idx -= 4;
            break;
        }
      }
    }
  }
  if (idx == 7) {
    for (uint8_t b = 0; b < ANGLE_OPTIONS; b++) {
      if (angle_buttons[b].contains(p.x, p.y)) {
        switch (b) {
          case ANGLE_LEFT:
            angle_menu();
            break;
          case ANGLE_RIGHT:
            angle_menu();
            break;
          case ANGLE_BACK:
            menu();
            idx -= 5;
            break;
        }
      }
    }
  }

  digitalWrite(13, HIGH);

  p = waitOneTouch();

  digitalWrite(13, LOW);

  // Map of values

  p.x = mapXValue(p);
  p.y = mapYValue(p);
  if (flag == 1) {
    for (int r = 0; r < 215; ++r) {
      delete[] new_arr[r];
    }
    delete[] new_arr;

    for (int r = 0; r < configurator.getVerSection(); ++r) {
      delete[] source_arr[r];
    }
    delete source_arr;
  }
}

void main_menu() {
  tft.fillScreen(BLACK);


  tft.setTextSize (1);

  // Header

  tft.fillRect(0, 0, width, 10, RED);
  tft.fillRect(0, 179, 5, 1, RED);
  tft.fillRect(234, 179, 5, 1, RED);
  tft.setCursor (95, 0);
  tft.setTextColor(WHITE);
  tft.println("MAIN MENU");

  // Footer

  TSPoint p; // Only for show initial values
  p.x = 0;
  p.y = 0;
  p.z = 0;


  // Buttons

  for (uint8_t i = 0; i < 2; i++) {
    buttons[i].drawButton();
  }
}
int start(int flag, float temperature, double** matrix) {
  tft.fillScreen(BLACK);

  //source_arr = configurator.measure();
  double** test = new double*[8];
  for (int i = 0; i < 8; ++i) {
    test[i] = new double[8];
  }
  for (int i = 0; i < 8; ++i) {
    for (int j  = 0; j < 8; ++j) {
      test[i][j] = 16 + j;
    }
  }
  new_arr = interpolateArray(test, configurator.getVerSection(), configurator.getHorSection(),
                             35, 25);
  tft.setTextSize (1);

  // Header
  uint16_t start_colors[15] = {RED, BLUE};

  for (uint8_t i = 0; i < 35; ++i) {
    for (uint8_t j = 0; j < 25; ++j) {
      pixel_color = rol_colors[int(32.0 * (new_arr[i][j] - 16) / (24 - 16))];
      tft.fillRect(0 + 6 * i, 0 + 12 * j, 9, 9, pixel_color);
    }
  }
  for (int i = 0; i < 8; ++i) {
    delete test[i];
  }
  delete test;
  tft.setCursor (95, 0);
  tft.setTextColor(WHITE);
  tft.println("TEMPERATURE");
  tft.setCursor (95, 300);
  tft.println(temperature);
  // Footer

  TSPoint p; // Only for show initial values
  p.x = 0;
  p.y = 0;
  p.z = 0;
  flag = 1;

  // Buttons
  for (uint8_t i = 0; i < 2; i++) {
    start_buttons[i].drawButton();
  }
  return flag;
}
void grid_menu() {
  tft.fillScreen(BLACK);


  tft.setTextSize (1);

  // Header

  tft.fillRect(0, 0, width, 10, RED);

  tft.setCursor (95, 0);
  tft.setTextColor(WHITE);
  tft.println("GRID");
  tft.setCursor(95, 300);
  tft.setTextColor(WHITE);
  tft.println("GRID OPTION");
  // Footer

  TSPoint p; // Only for show initial values
  p.x = 0;
  p.y = 0;
  p.z = 0;


  // Buttons

  for (uint8_t i = 0; i < 3; i++) {
    grid_buttons[i].drawButton();
  }
}
void color_menu() {
  tft.fillScreen(BLACK);


  tft.setTextSize (1);

  // Header

  tft.fillRect(0, 0, width, 10, RED);

  tft.setCursor (95, 0);
  tft.setTextColor(WHITE);
  tft.println("COLOR");
  tft.setCursor(95, 300);
  tft.println("COLOR OPTION");

  // Footer

  TSPoint p; // Only for show initial values
  p.x = 0;
  p.y = 0;
  p.z = 0;


  // Buttons

  for (uint8_t i = 0; i < 3; i++) {
    color_buttons[i].drawButton();
  }
}
void time_menu() {
  tft.fillScreen(BLACK);


  tft.setTextSize (1);

  // Header

  tft.fillRect(0, 0, width, 10, RED);

  tft.setCursor (95, 0);
  tft.setTextColor(WHITE);
  tft.println("TIME");
  tft.setCursor(95, 300);
  tft.println("TIME OPTION");

  // Footer

  TSPoint p; // Only for show initial values
  p.x = 0;
  p.y = 0;
  p.z = 0;


  // Buttons

  for (uint8_t i = 0; i < 3; i++) {
    time_buttons[i].drawButton();
  }
}
void angle_menu() {
  tft.fillScreen(BLACK);


  tft.setTextSize (1);

  // Header

  tft.fillRect(0, 0, width, 10, RED);

  tft.setCursor (95, 0);
  tft.setTextColor(WHITE);
  tft.println("ANGLE");
  tft.setCursor(95, 300);
  tft.println("ANGLE OPTION");
  // Footer

  TSPoint p; // Only for show initial values
  p.x = 0;
  p.y = 0;
  p.z = 0;


  // Buttons

  for (uint8_t i = 0; i < 3; i++) {
    angle_buttons[i].drawButton();
  }
}
void menu() {
  tft.fillScreen(BLACK);


  tft.setTextSize (1);

  // Header

  tft.fillRect(0, 0, width, 10, RED);

  tft.setCursor (95, 0);
  tft.setTextColor(WHITE);
  tft.println("SETTINGS");

  // Footer

  TSPoint p; // Only for show initial values
  p.x = 0;
  p.y = 0;
  p.z = 0;


  // Buttons

  for (uint8_t i = 0; i < 5; i++) {
    menu_buttons[i].drawButton();
  }

}


TSPoint waitOneTouch() {

  TSPoint p;

  do {
    p = ts.getPoint();

    pinMode(XM, OUTPUT); //Pins configures again for TFT control
    pinMode(YP, OUTPUT);

  } while ((p.z < MINPRESSURE ) || (p.z > MAXPRESSURE));

  return p;
}

// Draw a border

void drawBorder () {

  uint16_t width = tft.width() - 1;
  uint16_t height = tft.height() - 1;
  uint8_t border = 10;

  tft.fillScreen(RED);
  tft.fillRect(border, border, (width - border * 2), (height - border * 2), WHITE);

}




// Initialize buttons

void initializeButtons() {

  uint16_t x = 120;
  uint16_t y = 170;
  uint16_t w = 200;
  uint16_t h = 70;
  uint16_t set_y = 50;
  uint16_t set_h = 40;
  uint8_t textSize = 1;

  char main_buttonlabels[2][20] = {"START", "SETTINGS"};
  char menu_buttonlabels[5][20] = {"GRID", "COLOR", "TIME", "ANGLE", "BACK"};
  char grid_buttonlabels[3][20] = {"-", "+", "BACK"};
  char color_buttonlabels[3][20] = {"<-", "->", "BACK"};
  char time_buttonlabels[3][20] = {"-", "+", "BACK"};
  char angle_buttonlabels[3][20] = {"-", "+", "BACK"};
  char start_buttonlabels[2][20] = {"BACK", "REFRESH"};

  uint16_t main_buttoncolors[15] = {RED, BLUE};

  for (uint8_t b = 0; b < 2; b++) {
    buttons[b].initButton(&tft,                           // TFT object
                          x,  y + b * 100,              // x, y,
                          w, h, WHITE, main_buttoncolors[b], WHITE,    // w, h, outline, fill,
                          main_buttonlabels[b], textSize);             // text
  }
  for (uint8_t b = 0; b < 5; b++) {
    menu_buttons[b].initButton(&tft,
                               x, set_y + b * 60,
                               w, set_h, WHITE, BLUE, WHITE,
                               menu_buttonlabels[b], textSize);
  }
  // Save the y position to avoid draws

  for (uint8_t b = 0; b < 3; b++) {
    grid_buttons[b].initButton(&tft,
                               x, set_y + b * 60,
                               w, set_h, WHITE, BLUE, WHITE,
                               grid_buttonlabels[b], textSize);
  }
  for (uint8_t b = 0; b < 3; b++) {
    color_buttons[b].initButton(&tft,
                                x, set_y + b * 60,
                                w, set_h, WHITE, BLUE, WHITE,
                                color_buttonlabels[b], textSize);
  }
  for (uint8_t b = 0; b < 3; b++) {
    time_buttons[b].initButton(&tft,
                               x, set_y + b * 60,
                               w, set_h, WHITE, BLUE, WHITE,
                               time_buttonlabels[b], textSize);
  }
  for (uint8_t b = 0; b < 3; b++) {
    angle_buttons[b].initButton(&tft,
                                x, set_y + b * 60,
                                w, set_h, WHITE, BLUE, WHITE,
                                angle_buttonlabels[b], textSize);
  }
  for (uint8_t b = 0; b < 2; b++) {
    start_buttons[b].initButton(&tft,
                                x, 230 + b * 60,
                                w, 45, WHITE, BLUE, WHITE,
                                start_buttonlabels[b], textSize);
  }

  buttons_y = y;

}

// Map the coordinate X
uint16_t mapXValue(TSPoint p) {

  uint16_t x = map(p.x, TS_MINX, TS_MAXX, 0, tft.width());

  //Correct offset of touch. Manual calibration
  //x+=1;

  return x;

}

// Map the coordinate Y

uint16_t mapYValue(TSPoint p) {

  uint16_t y = map(p.y, TS_MINY, TS_MAXY, 0, tft.height());

  //Correct offset of touch. Manual calibration
  //y-=2;

  return y;
}
